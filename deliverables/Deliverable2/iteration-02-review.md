# Water For The World(W4TW) - Missing Seven
Time: November 6, 2022\
Location: google meet

## Q1. Decisions that turned out well

The most important process-related decision that turned out to be successful is the task division decision. At the beginning of the project, we first have a meeting to talk about our personal information. We ask each of the team members questions about their strengths and weaknesses and what they can bring to the project. This exercise would allow us to gauge team members accurately and to distribute tasks accordingly. Also, we consider team members’ own preferences, if there is a team member who is experienced in frontend programming but this time wants to try the backend. We are more than willing to assign backend tasks to him if there are enough members working on frontend. We believe this decision turned out to be successful because in this way each of the members can make the most of their potential, and at the same time each member has a higher chance to work on the tasks they want. We believed this decision can make our programming process more efficient and it did.

The next important process-related decision that turned out to be successful is the branch creating decision. After we finish dividing tasks, we are separated into two groups (frontend and backend). Now we are facing a difficult situation since each of us has a different task, some tasks need to collaborate with other tasks, and some do not. Those are some complicated work and can be easy to mess up because of others' changes. So we decide to create multiple branches based on task needs. For example, we have a specific branch for frontend user interfaces, and for the backend, we have the MultipleChoiceTaskIntegration branch. Those branches can prevent our untested codes from damaging the main branch which is the branch we need to submit. Branches allow us to develop features, fix bugs, or safely experiment with new ideas in a contained area of our project. Finally, when we are sure that our branch is functioning well and is tested, we can merge it into the main branch. This is why I think this decision turned out to be successful.

Next is the code reviewing decision. When we are trying to merge our own branch with the main branch, we need to add a pull request and comment on what task or functionality we implement. We believe those pull requests let us tell other team members about changes we've pushed to a branch in the repository on GitHub. Once a pull request is opened, all other members can discuss and review the potential changes with collaborators and add follow-up commits before the changes are merged into the base branch. In order to make this review process safer and more precise, we changed the reviewer number setting to 3 which means in order for branch A’s change to be merged into the main branch, we need three of the team members to review the code and agree with the request. We believe in this way we can eliminate errors and make code structure more readable to others.

The last process-related decision that turned out to be successful is the communication decision. Another wise decision that I think is we keep close communication. After forming a project team, we created a chat group, and everyone is in there. When encountering a problem, a group member can put it into a chat group and someone who is free can help him with this problem, which improves the efficiency of writing code. And we have at least one meeting among our group members and one meeting with Engineers Without Borders Canada a week. Meeting among our group members mainly let everyone show their progress on the project and decide the next direction. And meeting with Engineers Without Borders Canada mainly show the demo application to them to ensure our work is what they want.



## Q2. Decisions that did not turn out as well as we hoped

The most important process-related decision that was not as successful as we thought it would be is the frontend programming based on the backend demanding decision. As computer science students, we are aware of the importance of connecting the frontend and backend smoothly. So before we do each task, we always talk about the details first as a group. We first decide on the template and come up with the desired outcome, then we ask the opinion of the backend group to list all the user interface functionalities they need, what type of ui component(buttons, input textbox etc) they want and what type of the variable they are going to use for each user interface. After gathering  that information, the frontend team can start working on it based on the list.  We thought this decision can make the later merge more smoothly and successfully, but actually, the later merge process is still very difficult. The formal information we listed for each ui is not enough. When the backend tries to write corresponding files, we find that the backend coding structure does not go with the frontend UI very well, so we spend more time fixing the UI so that it can match our structure. This is the decision that was not as successful as we thought it would be. In future programming, we should not only consider the basic variable's type but also consider the structure's reliability and the doability of the merge.

the second important decision that was not successful would be the updating decisions. During our process artifact of defining requirements, we needed to build our Class Responsibility Collaborator (CRC) model for the water filter application. Since many of us were having midterm during this period, it was difficult to set up a meeting time that was available for all memeber. In this case, we decided to use the strategy that as long as the meeting time was available for more than four team members, we would conduct a meeting. Later we would update the progress to the members who were not able to attend the meeting. Initially, we thought it would be successful as we were making the progress without waiting for everyone's free time. However, we did not consider that the teammates who missed the meeting also had new thoughts that wanted to be shared with the team. At the end, we spent extra time not making progress but kept updating and discussing new thoughts and ideas. This significantly delayed our process. We could not move on to our next stage on time.

The last decision that was not successful would be the testing strategy. During our process artifact of testing the application, we decided to run the virtual application to test it instead of using test case. We thought this method was efficient as we did not need to spend time writing the test case for each class. Some edge cases might also not be able to be considered when we think about the test case. However, when we implemented this strategy, it was indeed very difficult to find the error without the test case. We needed to brouse through every component of the code and determine which part went wrong. This process took so much time and we spent unnecessary time on looking for the errors instaead of straight away solving them.


## Q3. Planned changes

We planed to meet in-person every weekend to work together, but it's common that one or two of us were unavaialble. So we decided to hold all meetings online and record our Zoom meetings so that people who didn't come could review our project-related conversations and keep up with all the changes.

We intended to divide the work into distinct sections of the application, with each member responsible for finishing the area and fixing any issues that arose along the way. We found that this type of workflow is inefficient because each person is responsible for their own area. As a result, it is quite difficult to receive assistance from other members because it takes them a long time to grasp your code before they can identify the issue. We altered our process such that 2-3 individuals would manage a larger part (i.e. front-end, backend, database). Everyone will then be better equipped to understand the entire portion they are responsible for and be able to assist one another when facing obstacles.


## Q4. How was your product demo?
* How did you prepare your demo? \
\
Firstly, we did some internal demos to evaluate the level of presentation of the team's work on the project before showing it to the client. During these internal demo, we try to improve the demo on various aspects, for example, we added more visualization content, where we consider that texts and images are important for the client. Then, we finalized the process of demonstrate the working software and the explanation to the client on what we have done and what we haven't. Lastly, we decide to leave some time to the client to let them ask any questions related to the project.

* What did you manage to demo to your partner?\
\
We showed all the pages of the project that we currently done and all the features by now, for example, the multiple question page, the introduction/home page, and the main feature: the water filter simulator page. Although the UI is still simple and needed more polishing, but all the functionality works fine as demo goes. At last, we introduced some more feature that still need to be worked on and some ideas about features that can be add on the project.
In our first online demo with our partners, they gave us some feedback about our app. We made some changes on our project based on their feedback and created a recorded video demo to them. You can also find the demo video(demo.mp4) under the deliverables folder.

* Did your partner accept the features?\
\
Yes, our partner is quite satisfied on what we have by now, the project seems on the right track as they give us plenty free space to let us work on the project.

* Were there change requests?\
\
Not much, only probably need more UI improvement on the overall software experience.

* What did you learn from the demo from either a process or product perspective?\
\
Practice is important. There will be a lot of situations that we cannot expect if we didn't do some internal demo before demoing to the partner. Also, we should be clear on what is important and what is not before the demo, only showing important part will make the demo easy to follow and demonstrate good simplicity.

